package output

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	sigsyaml "sigs.k8s.io/yaml"
)

// SplitResult holds the result of splitting an RGD into per-resource files.
type SplitResult struct {
	// Files maps filename to content.
	Files map[string][]byte
	// Kustomization is the generated kustomization.yaml content.
	Kustomization []byte
}

// Split takes an RGD map and produces one file per resource,
// plus a kustomization.yaml that lists them all.
func Split(rgdMap map[string]interface{}, opts SerializeOptions) (*SplitResult, error) {
	specRaw, ok := rgdMap["spec"]
	if !ok {
		return nil, fmt.Errorf("RGD has no spec")
	}

	spec, ok := specRaw.(map[string]interface{})
	if !ok {
		return nil, fmt.Errorf("RGD spec is not a map")
	}

	resourcesRaw, ok := spec["resources"]
	if !ok {
		return nil, fmt.Errorf("RGD spec has no resources")
	}

	resources, ok := resourcesRaw.([]interface{})
	if !ok {
		return nil, fmt.Errorf("RGD resources is not a list")
	}

	if len(resources) == 0 {
		return nil, fmt.Errorf("RGD has no resources to split")
	}

	files := make(map[string][]byte, len(resources))
	var resourceFiles []string

	for _, res := range resources {
		resMap, ok := res.(map[string]interface{})
		if !ok {
			continue
		}

		id, ok := resMap["id"].(string)
		if !ok || id == "" {
			continue
		}

		// Build a single-resource RGD.
		singleRGD := makeSingleResourceRGD(rgdMap, resMap)

		data, err := Serialize(singleRGD, opts)
		if err != nil {
			return nil, fmt.Errorf("serializing resource %s: %w", id, err)
		}

		filename := id + ".yaml"
		files[filename] = data
		resourceFiles = append(resourceFiles, filename)
	}

	// Sort filenames for determinism.
	sort.Strings(resourceFiles)

	// Generate kustomization.yaml.
	kustomization, err := generateKustomization(resourceFiles)
	if err != nil {
		return nil, fmt.Errorf("generating kustomization.yaml: %w", err)
	}

	return &SplitResult{
		Files:         files,
		Kustomization: kustomization,
	}, nil
}

// WriteSplit writes split files to the specified output directory.
func WriteSplit(dir string, result *SplitResult) error {
	if err := os.MkdirAll(dir, 0o750); err != nil {
		return fmt.Errorf("creating output directory: %w", err)
	}

	// Sort filenames for deterministic write order.
	filenames := make([]string, 0, len(result.Files))
	for name := range result.Files {
		filenames = append(filenames, name)
	}

	sort.Strings(filenames)

	for _, name := range filenames {
		path := filepath.Join(dir, name)
		if err := os.WriteFile(path, result.Files[name], 0o644); err != nil { //nolint:gosec // RGD files aren't secret
			return fmt.Errorf("writing %s: %w", path, err)
		}
	}

	// Write kustomization.yaml.
	kPath := filepath.Join(dir, "kustomization.yaml")
	if err := os.WriteFile(kPath, result.Kustomization, 0o644); err != nil { //nolint:gosec // Not secret
		return fmt.Errorf("writing kustomization.yaml: %w", err)
	}

	return nil
}

// makeSingleResourceRGD creates an RGD map containing only the specified resource.
func makeSingleResourceRGD(fullRGD map[string]interface{}, resource map[string]interface{}) map[string]interface{} {
	result := make(map[string]interface{}, len(fullRGD))

	for k, v := range fullRGD {
		if k == "spec" {
			continue
		}

		result[k] = v
	}

	// Build spec with only one resource.
	origSpec, _ := fullRGD["spec"].(map[string]interface{})
	newSpec := make(map[string]interface{}, len(origSpec))

	for k, v := range origSpec {
		if k == "resources" {
			continue
		}

		newSpec[k] = v
	}

	newSpec["resources"] = []interface{}{resource}
	result["spec"] = newSpec

	return result
}

// kustomizationDoc is used for YAML serialization of kustomization.yaml.
type kustomizationDoc struct {
	APIVersion string   `json:"apiVersion"`
	Kind       string   `json:"kind"`
	Resources  []string `json:"resources"`
}

// generateKustomization builds a kustomization.yaml listing all resource files.
func generateKustomization(resourceFiles []string) ([]byte, error) {
	doc := kustomizationDoc{
		APIVersion: "kustomize.config.k8s.io/v1beta1",
		Kind:       "Kustomization",
		Resources:  resourceFiles,
	}

	data, err := sigsyaml.Marshal(doc)
	if err != nil {
		return nil, err
	}

	// Ensure trailing newline.
	if len(data) > 0 && data[len(data)-1] != '\n' {
		data = append(data, '\n')
	}

	// Add header comment.
	header := "# Generated by chart2kro â€” do not edit manually.\n"

	return append([]byte(header), data...), nil
}

// ValidateSplitFlags checks that --split and --output-dir are used together.
func ValidateSplitFlags(split bool, outputDir string) error {
	if split && outputDir == "" {
		return fmt.Errorf("--split requires --output-dir")
	}

	if outputDir != "" && !split {
		return fmt.Errorf("--output-dir requires --split")
	}

	return nil
}

// FormatKustomizeDir creates a directory with the RGD YAML and kustomization.yaml.
// Unlike Split, this writes a single RGD file instead of per-resource files.
func FormatKustomizeDir(dir string, rgdMap map[string]interface{}, opts SerializeOptions) error {
	if err := os.MkdirAll(dir, 0o750); err != nil {
		return fmt.Errorf("creating output directory: %w", err)
	}

	data, err := Serialize(rgdMap, opts)
	if err != nil {
		return fmt.Errorf("serializing RGD: %w", err)
	}

	// Derive filename from metadata name.
	filename := "rgd.yaml"
	if meta, ok := rgdMap["metadata"].(map[string]interface{}); ok {
		if name, ok := meta["name"].(string); ok && name != "" {
			filename = strings.ReplaceAll(name, " ", "-") + ".yaml"
		}
	}

	rgdPath := filepath.Join(dir, filename)
	if err := os.WriteFile(rgdPath, data, 0o644); err != nil { //nolint:gosec // Not secret
		return fmt.Errorf("writing %s: %w", rgdPath, err)
	}

	kDoc, err := generateKustomization([]string{filename})
	if err != nil {
		return fmt.Errorf("generating kustomization.yaml: %w", err)
	}

	kPath := filepath.Join(dir, "kustomization.yaml")
	if err := os.WriteFile(kPath, kDoc, 0o644); err != nil { //nolint:gosec // Not secret
		return fmt.Errorf("writing kustomization.yaml: %w", err)
	}

	return nil
}
